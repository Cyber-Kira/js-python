<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/style.css">
    <title>Document</title>
</head>

<body>
    <header class="header">
        <nav class="header_nav">
            <ul class="header_nav_list">
                <li class="header_nav_list_item"><a class="header_nav_list_item_link" href="#">Уроки</a></li>
                <li class="header_nav_list_item"><a class="header_nav_list_item_link" href="#">Практические</a></li>
                <li class="header_nav_list_item"><a class="header_nav_list_item_link" href="#">Лабораторные</a></li>
                <li class="header_nav_list_item"><a class="header_nav_list_item_link" href="#">Тест</a></li>
            </ul>
        </nav>
    </header>

    <div class="wrapper">
        <div class="sidebar">
            <ul>
                <li><a href="#">Уроки</a></li>
                <li><a href="#">Практические</a></li>
                <li><a href="#">Лабораторные</a></li>
                <li><a href="#">Тест</a></li>
            </ul>
        </div>
<div class="main_content">
            <h1>Перегрузка операторов</h1>
            <p>Перегрузка операторов — один из способов реализации полиморфизма, когда мы можем задать свою реализацию
                какого-либо метода в своём классе.</p>
            <p>Например, у нас есть два класса:</p>
<pre>
<code>
class A:
    def go(self):
        print('Go, A!')

class B(A):
    def go(self, name):
        print('Go, {}!'.format(name))
</code>
</pre>
            <p>В данном примере класс B наследует класс A, но переопределяет метод go, поэтому он имеет мало общего с
                аналогичным методом класса A.</p>
            <p>Однако в python имеются методы, которые, как правило, не вызываются напрямую, а вызываются встроенными
                функциями или операторами.</p>
            <p>Например, метод __init__ перегружает конструктор класса. Конструктор - создание экземпляра класса.</p>
<pre>
<code>
>>> class A:
...     def __init__(self, name):
...         self.name = name
...
>>> a = A('Vasya')
>>> print(a.name)
Vasya
</code>
</pre>
            <p>Собственно, далее пойдёт список таких "магических" методов.</p>
            <p><strong>__new__(cls[, ...])</strong> — управляет созданием экземпляра. В качестве обязательного аргумента принимает класс
                (не путать с экземпляром). Должен возвращать экземпляр класса для его последующей его передачи методу
                __init__.</p>
            <p><strong>__init__(self[, ...])</strong> - как уже было сказано выше, конструктор.</p>
            <p><strong>__del__(self)</strong> - вызывается при удалении объекта сборщиком мусора.</p>
            <p><strong>__repr__(self)</strong> - вызывается встроенной функцией repr; возвращает "сырые" данные, использующиеся для
                внутреннего представления в python.</p>
            <p><strong>__str__(self)</strong> - вызывается функциями str, print и format. Возвращает строковое представление объекта.</p>
            <p><strong>__bytes__(self)</strong> - вызывается функцией bytes при преобразовании к <a href="#">байтам</a>.</p>
            <p><strong>__format__(self, format_spec)</strong> - используется функцией format (а также методом format у строк).</p>
            <p><strong>__lt__(self, other)</strong> - x < y вызывает x.__lt__(y).</p> <p>__le__(self, other) - x ≤ y вызывает
                    x.__le__(y).</p>
            <p><strong>__eq__(self, other)</strong> - x == y вызывает x.__eq__(y).</p>
            <p><strong>__ne__(self, other)</strong> - x != y вызывает x.__ne__(y)</p>
            <p><strong>__gt__(self, other)</strong> - x > y вызывает x.__gt__(y).</p>
            <p><strong>__ge__(self, other)</strong> - x ≥ y вызывает x.__ge__(y).</p>
            <p><strong>__hash__(self)</strong> - получение хэш-суммы объекта, например, для добавления в словарь.</p>
            <p><strong>__bool__(self)</strong> - вызывается при проверке истинности. Если этот метод не определён, вызывается метод
                __len__ (объекты, имеющие ненулевую длину, считаются истинными).</p>
            <p><strong>__getattr__(self, name)</strong> - вызывается, когда атрибут экземпляра класса не найден в обычных местах
                (например, у экземпляра нет метода с таким названием)</p>
            <p><strong>__setattr__(self, name, value)</strong> - назначение атрибута.</p>
            <p><strong>__delattr__(self, name)</strong> - удаление атрибута (del obj.name).</p>
            <p><strong>__call__(self[, args...])</strong> - вызов экземпляра класса как функции.</p>
            <p>__len__(self) - длина объекта.</p>
            <p><strong>__getitem__(self, key)</strong> - доступ по индексу (или ключу).</p>
            <p><strong>__setitem__(self, key, value)</strong> - назначение элемента по индексу.</p>
            <p>__delitem__(self, key) - удаление элемента по индексу.</p>
            <p><strong>__iter__(self)</strong> - возвращает итератор для контейнера.</p>
            <p><strong>__reversed__(self)</strong> - итератор из элементов, следующих в обратном порядке.</p>
            <p><strong>__contains__(self, item)</strong> - проверка на принадлежность элемента контейнеру (item in self).</p>

            <h2>Перегрузка арифметических операторов</h2>
            <p><strong>__add__(self, other)</strong> - сложение. x + y вызывает x.__add__(y).</p>
            <p><strong>__sub__(self, other)</strong> - вычитание (x - y).</p>
            <p><strong>__mul__(self, other)</strong> - умножение (x * y).</p>
            <p><strong>__truediv__(self, other)</strong> - деление (x / y).</p>
            <p><strong>__floordiv__(self, other)</strong> - целочисленное деление (x // y).</p>
            <p><strong>__mod__(self, other)</strong> - остаток от деления (x % y).</p>
            <p><strong>__divmod__(self, other)</strong> - частное и остаток (divmod(x, y)).</p>
            <p><strong>__pow__(self, other[, modulo])</strong> - возведение в степень (x ** y, pow(x, y[, modulo])).</p>
            <p><strong>__lshift__(self, other)</strong> - битовый сдвиг влево (x << y).</p> <p>__rshift__(self, other) - битовый сдвиг
                    вправо (x >> y).</p>
            <p><strong>_and__(self, other)</strong> - битовое И (x & y).</p>
            <p><strong>__xor__(self, other)</strong> - битовое ИСКЛЮЧАЮЩЕЕ ИЛИ (x ^ y).</p>
            <p><strong>__or__(self, other)</strong> - битовое ИЛИ (x | y).</p>
            <p>Пойдём дальше.</p>
            <p><strong>__radd__(self, other)</strong>,</p>
            <p><strong>__rsub__(self, other)</strong>,</p>
            <p><strong>__rmul__(self, other)</strong>,</p>
            <p><strong>__rtruediv__(self, other)</strong>,</p>
            <p><strong>__rfloordiv__(self, other)</strong>,</p>
            <p><strong>__rmod__(self, other)</strong>,</p>
            <p><strong>__rdivmod__(self, other)</strong>,</p>
            <p><strong>__rpow__(self, other)</strong>,</p>
            <p><strong>__rlshift__(self, other)</strong>,</p>
            <p><strong>__rrshift__(self, other)</strong>,</p>
            <p><strong>__rand__(self, other)</strong>,</p>
            <p><strong>__rxor__(self, other)</strong>,</p>
            <p><strong>__ror__(self, other)</strong> - делают то же самое, что и арифметические операторы, перечисленные выше, но для
                аргументов, находящихся справа, и только в случае, если для левого операнда не определён соответствующий
                метод.</p>
            <p>Например, операция x + y будет сначала пытаться вызвать x.__add__(y), и только в том случае, если это не
                получилось, будет пытаться вызвать y.__radd__(x). Аналогично для остальных методов.</p>
            <p>Идём дальше.</p>
            <p><strong>__iadd__(self, other)</strong> - +=.</p>
            <p><strong>__isub__(self, other)</strong> - -=.</p>
            <p><strong>__imul__(self, other)</strong> - *=.</p>
            <p><strong>__itruediv__(self, other)</strong> - /=.</p>
            <p><strong>__ifloordiv__(self, other)</strong> - //=.</p>
            <p><strong>__imod__(self, other)</strong> - %=.</p>
            <p><strong>__ipow__(self, other[, modulo])</strong> - **=.</p>
            <p><strong>__ilshift__(self, other)</strong> - <<=.</p> <p>__irshift__(self, other) - >>=.</p>
            <p><strong>__iand__(self, other)</strong> - &=.</p>
            <p><strong>__ixor__(self, other)</strong> - ^=.</p>
            <p><strong>__ior__(self, other)</strong> - |=.</p>
            <p><strong>__neg__(self)</strong> - унарный -.</p>
            <p><strong>__pos__(self)</strong> - унарный +.</p>
            <p><strong>__abs__(self)</strong> - модуль (abs()).</p>
            <p><strong>__invert__(self)</strong> - инверсия (~).</p>
            <p><strong>__complex__(self)</strong> - приведение к complex.</p>
            <p><strong>__int__(self)</strong> - приведение к int.</p>
            <p><strong>__float__(self)</strong> - приведение к float.</p>
            <p><strong>__round__(self[, n])</strong> - округление.</p>
            <p><strong>__enter__(self), __exit__(self, exc_type, exc_value, traceback)</strong> - реализация менеджеров контекста.</p>
            <p>Рассмотрим некоторые из этих методов на примере двухмерного вектора, для которого переопределим некоторые
                методы:</p>
<pre>
<code>
import math

class Vector2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return 'Vector2D({}, {})'.format(self.x, self.y)

    def __str__(self):
        return '({}, {})'.format(self.x, self.y)

    def __add__(self, other):
        return Vector2D(self.x + other.x, self.y + other.y)

    def __iadd__(self, other):
        self.x += other.x
        self.y += other.y
        return self

    def<strong> __sub__(self, other):</strong>
        return Vector2D(self.x - other.x, self.y - other.y)

    def __isub__(self, other):
        self.x -= other.x
        self.y -= other.y
        return self

    def __abs__(self):
        return math.hypot(self.x, self.y)

    def __bool__(self):
        return self.x != 0 or self.y != 0

    def __neg__(self):
        return Vector2D(-self.x, -self.y)

>>> x = Vector2D(3, 4)
>>> x
Vector2D(3, 4)
>>> print(x)
(3, 4)
>>> abs(x)
5.0
>>> y = Vector2D(5, 6)
>>> y
Vector2D(5, 6)
>>> x + y
Vector2D(8, 10)
>>> x - y
Vector2D(-2, -2)
>>> -x
Vector2D(-3, -4)
>>> x += y
>>> x
Vector2D(8, 10)
>>> bool(x)
True
>>> z = Vector2D(0, 0)
>>> bool(z)
False
>>> -z
Vector2D(0, 0)
</code>
</pre>
            <p>В заключение хочу сказать, что перегрузка специальных методов - вещь хорошая, но не стоит ей слишком
                злоупотреблять. Перегружайте их только тогда, когда вы уверены в том, что это поможет пониманию
                программного кода.</p>
        </div>
        <div class="info">
            <ul>
                <li><a href="#first">Скачать Python</a></li>
                <li><a href="#second">Установка Python на Windows</a></li>
            </ul>
        </div>
    </div>
</body>

</html>